"""
MiFlasher — Mi Unlock Flow

Xiaomi's unlock API requires proprietary signatures generated by their
Windows tool — it cannot be replicated via direct HTTP calls. 

What we CAN do (and this tool does):
  1. Generate the correct Mi Account login URL
  2. User logs in via browser
  3. We verify the redirect URL is valid (token present)
  4. Show clear next steps for fastboot unlock

For the actual bootloader unlock, USB + fastboot is required.
This tool handles both steps cleanly.
"""

import re
import sys
import time
import urllib.parse
from typing import Optional

try:
    import requests
    HAS_REQUESTS = True
except ImportError:
    HAS_REQUESTS = False


# ── Constants ─────────────────────────────────────────────────────────────────

LOGIN_URL = (
    "https://account.xiaomi.com/fe/service/login/password"
    "?checkSafeAddress=true"
    "&sid=unlockApi"
    "&qs=%253Fsid%253DunlockApi%2526checkSafeAddress%253Dtrue"
    "&callback=https%3A%2F%2Funlock.update.miui.com%2Fsts"
    "&_sign=fOqVnvn3CyShAptIWVb6J8Eh7l0%3D"
    "&serviceParam=%7B%22checkSafePhone%22%3Afalse%2C%22checkSafeAddress%22"
    "%3Atrue%2C%22lsrp_score%22%3A0.0%7D"
    "&showActiveX=false&theme=&needTheme=false&bizDeviceType=&_locale=id_ID"
)


# ── URL parsing ───────────────────────────────────────────────────────────────

def _parse_redirect(url: str) -> dict:
    """
    Parse all params from Xiaomi STS redirect URL.
    Real format: ?d=wb_xxx&ticket=0&auth=xxx&nonce=xxx&p_ts=xxx
    """
    try:
        parsed = urllib.parse.urlparse(url.strip())
        qs = urllib.parse.parse_qs(parsed.query, keep_blank_values=True)
        return {k: urllib.parse.unquote(v[0]) for k, v in qs.items()}
    except Exception:
        return {}


def _is_valid_redirect(url: str) -> bool:
    """Check if URL looks like a valid Xiaomi STS redirect."""
    return "unlock.update.miui.com" in url or "miui.com/sts" in url


def _extract_session_id(params: dict) -> Optional[str]:
    """Get the session identifier from parsed params."""
    return (params.get("d") or params.get("token") or
            params.get("passToken") or params.get("nonce"))


# ── Main class ────────────────────────────────────────────────────────────────

class MiUnlockWrapper:

    def __init__(self, log):
        self.log = log

    # ── Step 1: Browser login ─────────────────────────────────────────────────

    def _do_browser_login(self) -> dict:
        """
        Show login URL, wait for redirect URL paste.
        Returns parsed params dict, or empty dict on failure/cancel.
        """
        print()
        self.log.header("Mi Account Login")

        self.log.info("Open this URL in your browser and sign in with your Mi Account:")
        print()
        print(f"  \033[1;36m{LOGIN_URL}\033[0m")
        print()
        self.log.info("After login, browser will redirect to a URL like:")
        self.log.info("  \033[2mhttps://unlock.update.miui.com/sts?d=wb_xxx&auth=xxx...\033[0m")
        print()
        self.log.info("Copy the full URL from the browser address bar and paste it below.")
        self.log.warning("Page may appear blank — that is normal. Just copy the URL.")
        print()

        try:
            redirect = input("  \033[1;33m▶ Paste redirect URL: \033[0m").strip()
        except (EOFError, KeyboardInterrupt):
            print()
            self.log.info("Login cancelled.")
            return {}

        if not redirect:
            self.log.error("No URL entered.")
            return {}

        if not _is_valid_redirect(redirect):
            self.log.warning("URL doesn't look like a Xiaomi redirect — trying anyway...")

        params = _parse_redirect(redirect)
        if not params:
            self.log.error("Could not parse URL. Please paste the complete redirect URL.")
            return {}

        session_id = _extract_session_id(params)
        if not session_id:
            self.log.error("No session token found in URL.")
            self.log.info("Expected params: d=, token=, or nonce= in the URL.")
            return {}

        print()
        self.log.success(f"Login verified! Session: {session_id[:30]}...")
        self.log.debug(f"Params received: {list(params.keys())}")
        return params

    # ── Step 2: Show account status & next steps ──────────────────────────────

    def _show_account_status(self, params: dict):
        """Display parsed account info and eligibility guidance."""
        print()
        self.log.header("Account Status")

        # Show what we know from the URL params
        rows = []
        if params.get("d"):
            rows.append(("Session ID",   params["d"][:40] + "..."))
        if params.get("p_ur"):
            rows.append(("Region",       params["p_ur"]))
        if params.get("p_idc"):
            rows.append(("Server IDC",   params["p_idc"]))
        if params.get("p_ts"):
            ts = int(params["p_ts"]) // 1000
            from datetime import datetime
            dt = datetime.fromtimestamp(ts).strftime("%Y-%m-%d %H:%M:%S")
            rows.append(("Login Time",   dt))
        if params.get("ticket"):
            rows.append(("Ticket",       params["ticket"]))
        if params.get("m"):
            rows.append(("Auth Method",  params["m"]))

        if rows:
            self.log.table(["Property", "Value"], rows, title="Session Info")

        self.log.success("Mi Account authentication successful ✅")
        print()
        self.log.info("Note: Xiaomi's unlock API uses proprietary signing that requires")
        self.log.info("the official Mi Unlock tool (Windows) for the final approval step.")
        self.log.info("This tool handles everything else — see next steps below.")

    # ── Step 3: Next steps guide ──────────────────────────────────────────────

    def _show_next_steps(self, params: dict):
        print()
        self.log.header("Unlock Next Steps")

        self.log.info("Your Mi Account is authenticated. To complete bootloader unlock:")
        print()

        steps = [
            ("Ensure waiting period done",
             "Settings → Additional Settings → Developer Options → Mi Unlock Status\n"
             "         Must show 'Added successfully' and 7+ days passed"),
            ("Boot device to Fastboot",
             "Power off device → hold Vol- + Power until Fastboot screen appears"),
            ("Connect via USB",
             "Use original USB cable for best compatibility"),
            ("Run fastboot unlock",
             "miflasher unlock --fastboot-only\n"
             "         OR: fastboot flashing unlock"),
            ("Confirm on device screen",
             "Use Vol keys to select 'Unlock bootloader', Power to confirm"),
            ("Wait for factory reset",
             "Device will reboot and wipe all data — this is normal"),
        ]

        for i, (title, detail) in enumerate(steps, 1):
            print(f"  \033[1;36m{i}.\033[0m \033[1m{title}\033[0m")
            print(f"     \033[2m{detail}\033[0m")
            print()

        self.log.warning("Make sure you have backed up all data before step 4!")

    # ── Fastboot-only unlock (USB) ────────────────────────────────────────────

    def fastboot_unlock(self) -> bool:
        import subprocess

        self.log.header("Fastboot Unlock")

        def run(cmd):
            try:
                r = subprocess.run(cmd, capture_output=True, text=True, timeout=30)
                return r.returncode == 0, (r.stdout + r.stderr).strip()
            except FileNotFoundError:
                return False, f"Command not found: {cmd[0]}"
            except Exception as e:
                return False, str(e)

        self.log.step(1, 3, "Checking for fastboot device...")
        ok, out = run(["fastboot", "devices"])
        if not out.strip():
            self.log.error("No device detected in fastboot mode.")
            self.log.info("Hold Vol- + Power button until you see the fastboot screen.")
            self.log.info("Then connect USB and retry: miflasher unlock --fastboot-only")
            return False
        serial = out.split()[0] if out.split() else "unknown"
        self.log.success(f"Device found: {serial}")

        self.log.step(2, 3, "Sending unlock command...")
        ok, out = run(["fastboot", "flashing", "unlock"])
        if ok or "okay" in out.lower():
            self.log.success("Unlock command accepted.")
        else:
            self.log.warning(f"'flashing unlock' failed, trying 'oem unlock'...")
            ok, out = run(["fastboot", "oem", "unlock"])
            if not ok and "okay" not in out.lower():
                self.log.error(f"Unlock command rejected: {out}")
                self.log.info("Your device may require Mi Account authorization first.")
                self.log.info("Run: miflasher unlock  (without --fastboot-only)")
                return False

        self.log.step(3, 3, "Verifying unlock state...")
        _, out = run(["fastboot", "getvar", "unlocked"])
        if "yes" in out.lower():
            self.log.success("Bootloader is now UNLOCKED ✅")
            self.log.warning("Device will factory reset on next boot.")
        else:
            self.log.info("Check device screen and confirm the unlock dialog if shown.")
        return True

    # ── Main entry ────────────────────────────────────────────────────────────

    def run(self, token: Optional[str] = None, fastboot_only: bool = False) -> bool:
        if fastboot_only:
            return self.fastboot_unlock()

        # Use provided token or do browser login
        if token:
            self.log.info(f"Using provided token: {token[:24]}...")
            params = {"d": token}
        else:
            params = self._do_browser_login()
            if not params:
                return False

        self._show_account_status(params)
        self._show_next_steps(params)
        return True


# ── Legacy shim ───────────────────────────────────────────────────────────────

def run_miunlock() -> bool:
    from core.logger import Logger
    log = Logger()
    return MiUnlockWrapper(log).run()
